From 6816d4f7256455d73bbc05cff69fdb5257714c8a Mon Sep 17 00:00:00 2001
From: Corey Minyard <cminyard@mvista.com>
Date: Sat, 8 Feb 2014 10:03:07 -0600
Subject: [PATCH] Allow the output file to be stdout

Remove the need for seeking when writing the elf file and default to stdout
if an output file is not supplied.
---
 elfc.c       |   28 +++++++++++-----------------
 kdump-tool.1 |    5 +++--
 kdump-tool.c |   42 ++++++++++++++++++++----------------------
 3 files changed, 34 insertions(+), 41 deletions(-)

diff --git a/elfc.c b/elfc.c
index 24a746d..8a7bb69 100644
--- a/elfc.c
+++ b/elfc.c
@@ -291,6 +291,10 @@ elfc_phdr_tmpfile_alloc(struct elfc *e)
 	return tf;
 }
 
+/*
+ * Create a copy of the contents in a temparary file.  This way if we
+ * are reading and writing the same file, the data won't be clobbered.
+ */
 static int
 elfc_phdr_tmpfile_pre_write(struct elfc *e, GElf_Phdr *phdr,
 			    void *data, void *userdata)
@@ -1125,12 +1129,6 @@ write_elf32_ehdr(struct elfc *e)
 	Elf32_Ehdr e32;
 	int rv;
 
-	rv = lseek(e->fd, 0, SEEK_SET);
-	if (rv == -1) {
-		e->eerrno = errno;
-		return -1;
-	}
-
 	memcpy(e32.e_ident, e->hdr.e_ident, sizeof(e32.e_ident));
 #define EhdrE(type, name) e32.e_ ## name = elfc_put ## type(e, e->hdr.e_ ## name);
 	Ehdr_Entries;
@@ -1154,12 +1152,6 @@ write_elf64_ehdr(struct elfc *e)
 	Elf64_Ehdr e64;
 	int rv;
 
-	rv = lseek(e->fd, 0, SEEK_SET);
-	if (rv == -1) {
-		e->eerrno = errno;
-		return -1;
-	}
-
 	memcpy(e64.e_ident, e->hdr.e_ident, sizeof(e64.e_ident));
 #define EhdrE(type, name) e64.e_ ## name = elfc_put ## type(e, e->hdr.e_ ## name);
 	Ehdr_Entries;
@@ -1881,6 +1873,9 @@ elfc_write(struct elfc *e)
 	e->hdr.e_phnum = e->num_phdrs;
 	e->hdr.e_phentsize = elfc_phdr_size_one(e);
 
+	/* Ignore errors here, it will fail on stdin. */
+	(void) lseek(e->fd, 0, SEEK_SET);
+
 	if (e->hdr.e_ident[EI_CLASS] == ELFCLASS32)
 		rv = write_elf32_ehdr(e);
 	else
@@ -1915,11 +1910,10 @@ elfc_write(struct elfc *e)
 
 	for (i = 0; i < e->num_phdrs; i++) {
 		if (e->phdrs[i].do_write) {
-			rv = lseek(e->fd, e->phdrs[i].p.p_offset, SEEK_SET);
-			if (rv == -1) {
-				e->eerrno = errno;
-				goto out;
-			}
+			/*
+			 * Should already be in the correct position
+			 * here, no need to seek.
+			 */
 			rv = e->phdrs[i].do_write(e, e->fd, &e->phdrs[i].p,
 						  e->phdrs[i].data,
 						  e->phdrs[i].userdata);
diff --git a/kdump-tool.1 b/kdump-tool.1
index 988fac4..41f300d 100644
--- a/kdump-tool.1
+++ b/kdump-tool.1
@@ -60,7 +60,8 @@ will process /dev/mem and /proc/vmcore into a pelf file.  This is
 generally preferred on a target system, pelf files are usually smaller
 than velf files and they are quicker to process.  Plus a velf file may
 not have all of physical memory, in case you are in a desperate
-situation and need to get to userland memory.
+situation and need to get to userland memory.  Note that the output
+will go to standard output if you don't specify -o.
 
 .BR kdump-tool tovelf -i <pelf file> -o <velf file>
 will process the pelf file into a velf file.
@@ -83,7 +84,7 @@ Output help.
 Set the location of the oldmem file.  The default -s /dev/mem.
 .TP
 .I "\-\-outfile|-o <output file>"
-Set the output file, this parameter is required.
+Set the output file, output will go to stdout if this is not supplied.
 .TP
 .I "\-\-vmcore|-v <vmcore>"
 Set the location of the vmcore file, /proc/vmcore by default.
diff --git a/kdump-tool.c b/kdump-tool.c
index 2383941..095ecc5 100644
--- a/kdump-tool.c
+++ b/kdump-tool.c
@@ -277,11 +277,11 @@ topelf(int argc, char *argv[])
 	static const char *helpstr[] = {
 		"This info",
 		"File to use instead of /dev/mem",
-		"File send output to",
+		"File send output to instead of stdout",
 		"The vmcore file, defaults to /proc/vmcore",
 		NULL
 	};
-	int ofd = -1;
+	int ofd = 1;
 	int rv = 0;
 	struct elfc *elf = NULL;
 	struct vmcoreinfo_data vmci[] = {
@@ -325,14 +325,13 @@ topelf(int argc, char *argv[])
 	if (!vmci[0].found)
 		fprintf(stderr, "Warning: phys pgd ptr not in vmcore\n");
 
-	if (!outfile)
-		subcmd_usage("No output file given\n");
-
-	ofd = creat(outfile, 0644);
-	if (ofd == -1) {
-		fprintf(stderr, "Unable to open %s: %s\n", outfile,
-			strerror(errno));
-		goto out_err;
+	if (outfile) {
+		ofd = creat(outfile, 0644);
+		if (ofd == -1) {
+			fprintf(stderr, "Unable to open %s: %s\n", outfile,
+				strerror(errno));
+			goto out_err;
+		}
 	}
 
 	elfc_set_fd(elf, ofd);
@@ -347,7 +346,7 @@ topelf(int argc, char *argv[])
 out:
 	if (elf)
 		elfc_free(elf);
-	if (ofd != -1)
+	if ((ofd != -1) && (ofd != 1))
 		close(ofd);
 	return rv;
 
@@ -554,7 +553,7 @@ tovelf(int argc, char *argv[])
 		"This info",
 		"The input file, defaults to /dev/mem if intype is oldmem, "
 		"otherwise required",
-		"File send output to",
+		"File send output to, stdout if not specified",
 		"The vmcore file, defaults to /proc/vmcore, only for oldmem",
 		"The file type, either pelf or oldmem, defaults to pelf",
 		"The physical address of the kernel page descriptor",
@@ -562,7 +561,7 @@ tovelf(int argc, char *argv[])
 		NULL
 	};
 	int fd = -1;
-	int ofd = -1;
+	int ofd = 1;
 	int rv = 0;
 	GElf_Addr pgd;
 	int pgd_set = 0;
@@ -679,14 +678,13 @@ nopgd:
 		goto out_err;
 	}
 
-	if (!outfile)
-		subcmd_usage("No output file given\n");
-
-	ofd = creat(outfile, 0644);
-	if (ofd == -1) {
-		fprintf(stderr, "Unable to open %s: %s\n", outfile,
-			strerror(errno));
-		goto out_err;
+	if (outfile) {
+		ofd = creat(outfile, 0644);
+		if (ofd == -1) {
+			fprintf(stderr, "Unable to open %s: %s\n", outfile,
+				strerror(errno));
+			goto out_err;
+		}
 	}
 
 	velf = elfc_alloc();
@@ -747,7 +745,7 @@ out:
 		close(elfc_get_fd(elf));
 		elfc_free(elf);
 	}
-	if (ofd != -1)
+	if ((ofd != -1) && (ofd != 1))
 		close(ofd);
 	return rv;
 
-- 
1.7.9.5

